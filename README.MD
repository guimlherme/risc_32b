# A custom CPU with accelerator

## How to simulate

Include all .vhd files of this folder in a project, and use your favorite VHDL simulation tool with the testbench_cpu.vhd.

The memories will automatically try to load a file named `output.txt`. There are two ways to generate it:

1. By using the file `python bin2str.py input.out`, with input.out being the binary generated by the compiler.
2. By coding in assembly and using `python compiler.py input.asm`.

If you use ModelSim, I've provided the file `wave.do` that can be loaded into the Wave View to monitor some relevant signals.

All programs generated by the C compiler enter an infinite loop in the end of the execution, at around the address 40. So, if you want to run a program until it ends, it is a good idea to add a breakpoint for when the program counter hits this address.

Tcl command:
`when -label End sim:/testbench/UUT/fetch_inst/PC_counter="00000000000000000000000000101000" {stop}`

## Opcodes

List of opcodes accepted by the compiler

RV32I:
`[LUI, AUIPC, JAL, JALR, BEQ, BNE, BLT, BGE, BLTU, BGEU, LB, LH, LW, LBU, LHU, SB, SH, SW, ADDI, SLTI, SLTIU, XORI, ORI, ANDI, SLLI, SRLI, SRAI, ADD, SUB, SLL, SLT, SLTU, XOR, SRL, SRA, OR, AND]`

RV32M:
`[MUL]`

RV32F:
`[FADD.S, FSUB.S, FMUL.S, FEQ.S, FLT.S, FLE.S, FMV.X.W, FMV.W.X, FSGNJ.S, FSGNJN.S, FSGNJX.S, FCVT.S.W, FLW, FSW]`

Pseudo-Instructions:
`[MOV, NOP, FMOV, FMV, FMOV.S, FMV.S]`

For more information, analyze the contents of the file `compiler.py`

## Simulator

Even though Spike was the main simulator used in this project, I've also included in the folder `pysim/` a small simulator whose simplicity allows for a high degree of flexibility. With it, you can:

- Add a print/logging to a specific opcode command on `executor.py`
- Print arbitrary variables when the program counter reaches a specific value or a certain instruction is executed, by adding a conditional with the function debug() in the main file `program.py`.
- Explore the content of the registers each time it is read/set in `register.py`.

To run it, execute the file `program.py`. It loads the same `output.txt` described in the section `# How to simulate`. Also, there are some useful functions in `emulators.py`

## Estimating the impact of the accelerator

The execution time can be estimated by running the programs `mlp` and `accelerated`, available in the folder `tests/` with the VHDL simulator.

To estimate the number of memory accesses, run the small simulator (section `# Simulator`) with the programs `mlp` and `accelerated`, available in the folder `tests/`, then read the value in `prog.ram.access_counter` when it ends.

## Improvement points

This project was created with a purpose in itself, and it served as a wonderful learning journey. It still needs some modifications to become applicable in a real hardware. If you wish to give continuity to this project, feel free to contact me on LinkedIn (available on my profile).

Here are some of the non-trivial modifications that I've thought about:

- The flush logic is probably redundant. I'm pretty sure it can be incorporated into the reset.
- Only one type of intruction (load) needs both memory and write-back. Is there a way to optimize it?
- Currently, the fetch assumes that branch instructions won't be taken. The ideal would be to have a prefetch and do branch prediction.
- OOO execution, multicore support, etc..
